C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GF68_8051_MAIN
OBJECT MODULE PLACED IN .\src\GF68_8051_main.OBJ
COMPILER INVOKED BY: d:\8051_mcu_ide\install\developer\toolchains\keil_8051\9.60\BIN\C51.exe D:\8051_mcu_ide\install\GF6
                    -8_8051\src\GF68_8051_main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) INT
                    -VECTOR(0X0000) INTPROMOTE INCDIR(D:/8051_mcu_ide/install/developer/sdks/8051/v4.1.5//Device/shared/si8051Base;D:/8051_mc
                    -u_ide/install/developer/sdks/8051/v4.1.5//Device/C8051F300/inc) PRINT(.\src\GF68_8051_main.lst) COND PAGEWIDTH(120) PAGE
                    -LENGTH(65) OBJECT(.\src\GF68_8051_main.OBJ)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          #include <SI_C8051F300_Register_Enums.h>                // SFR declarations
   5          
   6          
   7          //-----------------------------------------------------------------------------
   8          // SiLabs_Startup() Routine
   9          // ----------------------------------------------------------------------------
  10          // This function is called immediately after reset, before the initialization
  11          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  12          // useful place to disable the watchdog timer, which is enable by default
  13          // and may trigger before main() in some instances.
  14          //-----------------------------------------------------------------------------
  15          void SiLabs_Startup (void)
  16          {
  17   1              PCA0MD &= ~0x40; // Disable the watchdog here
  18   1      }
  19          
  20          
  21          INTERRUPT_PROTO(Timer2_ISR, 5);
  22          void Timer2_Init(void);
  23          void Timer2_Disable(void);
  24          void Timer2_Enable(void);
  25          void Init_Device(void);
  26          void Interrupts_Init(void);
  27          unsigned char CheckP0B4PressTime(unsigned short Min, unsigned short Max);
  28          void wait_ms(unsigned short m_second);
  29          void Set_Timer0(void);
  30          void Start_Stop_timer(void);
  31          unsigned char PWM_toggle(void);
  32          unsigned char calculate_pwm_frequency (void);
  33          
  34          #define  POWEROFF     0x00
  35          #define  STARTUP      0x01
  36          #define  IDLE         0x02
  37          #define  BOOT_FAIL    0x03
  38          
  39          unsigned char BootStage;
  40          unsigned char BootFlag;
  41          
  42          unsigned short timer2recording = 0x0000;
  43          unsigned char TL0Temp = 0x00;
  44          unsigned char TH0Temp = 0x00;
  45          
  46          //-----------------------------------------------------------------------------
  47          // main() Routine
  48          // ----------------------------------------------------------------------------
  49          // Note: the software watchdog timer is not disabled by default in this
  50          // example, so a long-running program will reset periodically unless
  51          // the timer is disabled or your program periodically writes to it.
  52          //
C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 2   

  53          // Review the "Watchdog Timer" section under the part family's datasheet
  54          // for details. To find the datasheet, select your part in the
  55          // Simplicity Launcher and click on "Data Sheet".
  56          //-----------------------------------------------------------------------------
  57          int main (void)
  58          {
  59   1              Init_Device();
  60   1              Timer2_Init();
  61   1              Timer2_Disable();
  62   1              Interrupts_Init();
  63   1      
  64   1              BootFlag = 0x01;
  65   1              BootStage = STARTUP;
  66   1      
  67   1              while (1)
  68   1              {
  69   2                      switch(BootStage)
  70   2                      {
  71   3                      case STARTUP:
  72   3                              if(BootFlag == 0x01)
  73   3                              {
  74   4                                      if(CheckP0B4PressTime(16,500))
  75   4                                      {
  76   5                                              BootFlag = 0x02;
  77   5                                              Timer2_Enable();
  78   5                                      }
  79   4                              }
  80   3                              else if(BootFlag == 0x02)
  81   3                              {
  82   4                                      if(!P0_B6)
  83   4                                      {
  84   5                                              while(!P0_B6)
  85   5                                              {
  86   6                                                      if(timer2recording > 5000)
  87   6                                                      {
  88   7                                                              BootFlag = 0x01;
  89   7                                                              BootStage = BOOT_FAIL;
  90   7                                                              Timer2_Disable();
  91   7                                                              break;
  92   7                                                      }
  93   6                                              }
  94   5                                      }
  95   4      
  96   4                                      if((P0_B6) && (BootFlag == 0x02))
  97   4                                      {
  98   5                                              BootFlag = 0x03;
  99   5                                              Timer2_Disable();
 100   5                                              Timer2_Enable();
 101   5                                      }
 102   4                              }
 103   3                              else if(BootFlag == 0x03)
 104   3                              {
 105   4                                      if(timer2recording > 55000)
 106   4                                      {
 107   5                                              BootFlag = 0x01;
 108   5                                              BootStage = BOOT_FAIL;
 109   5                                              Timer2_Disable();
 110   5                                              break;
 111   5                                      }
 112   4      
 113   4                                      if(!P0_B6)
 114   4                                      {
 115   5                                              BootFlag = 0x01;
C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 3   

 116   5                                              BootStage = BOOT_FAIL;
 117   5                                              Timer2_Disable();
 118   5                                              break;
 119   5                                      }
 120   4      
 121   4                                      if(calculate_pwm_frequency() ==1)
 122   4                                      {
 123   5                                              BootFlag = 0x11;
 124   5                                              BootStage = IDLE;
 125   5                                              Timer2_Disable();
 126   5                                      }
 127   4                              }
 128   3                              break;
 129   3                      case IDLE:
 130   3                              if(BootFlag == 0x11)
 131   3                              {
 132   4                                      if(!P0_B6)
 133   4                                      {
 134   5                                              while(!P0_B6)
 135   5                                              {
 136   6                                                      if(CheckP0B4PressTime(16,500))
 137   6                                                      {
 138   7                                                              BootFlag = 0x02;
 139   7                                                              BootStage = STARTUP;
 140   7                                                              Timer2_Enable();
 141   7                                                              break;
 142   7                                                      }
 143   6                                              }
 144   5      
 145   5                                              if((P0_B6) && (BootFlag == 0x11))
 146   5                                              {
 147   6                                                      BootFlag = 0x12;
 148   6                                              }
 149   5                                      }
 150   4                              }
 151   3                              else if(BootFlag == 0x12)
 152   3                              {
 153   4                                      BootFlag = 0x03;
 154   4                                      BootStage = STARTUP;
 155   4                                      Timer2_Enable();
 156   4                              }
 157   3                              break;
 158   3                      case BOOT_FAIL:
 159   3                              P0_B3=0;
 160   3                              wait_ms(5);
 161   3                              P0_B2=1;
 162   3                              wait_ms(5);
 163   3                              P0_B2=0;
 164   3                              wait_ms(5);
 165   3                              P0_B3=1;
 166   3                              wait_ms(10);
 167   3                              P0_B0=0;
 168   3                              wait_ms(100);
 169   3                              P0_B0=1;
 170   3                              BootStage = STARTUP;
 171   3                              BootFlag = 0x01;
 172   3                              break;
 173   3                      case POWEROFF:
 174   3                              break;
 175   3                      }
 176   2      
 177   2              }                             // Spin forever
 178   1      }
C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 4   

 179          
 180          unsigned char CheckP0B4PressTime(unsigned short Min, unsigned short Max)
 181          {
 182   1              unsigned short checkloop = 0;
 183   1      
 184   1              for(checkloop=0;checkloop<=0xffff;checkloop++)
 185   1              {
 186   2                      if(!P0_B4)  wait_ms(1);
 187   2                      else break;
 188   2              }
 189   1      
 190   1              if((checkloop > Min) && (checkloop < Max))
 191   1                      return 1;
 192   1      
 193   1              return 0;
 194   1      }
 195          
 196          /*----------------------------------------------------------------------*/
 197          /* Calculate PWM frequency 1KHz*/
 198          // 255KHz Sample Rate, So 200-300 conters
 199          unsigned char calculate_pwm_frequency ()
 200          {
 201   1              unsigned short timercount = 0x0000;
 202   1              Set_Timer0();
 203   1              Start_Stop_timer();
 204   1              timercount = (TH0Temp<<8)| TL0Temp;
 205   1      
 206   1              if(timercount>= 232 && timercount <= 283) return 1;             // 1KHz range 0.9KHz~1.1KHz
 207   1              else if(timercount>= 120 && timercount <= 160) return 2;        // 1.82KHz      1.60KHz~2.13KHz
 208   1              else if (timercount >=77 && timercount <=94 ) return 3;         // about 2.7KHz~3.3KHz
 209   1              else if(timercount >=23 && timercount <=28 ) return 10;         // about 9KHz~11Hz for USB reset
 210   1              else return false;                                                                      // other false
 211   1      }
 212          
 213          void Set_Timer0()
 214          {
 215   1                      TMOD &= ~0x0F;
 216   1                      TMOD |=  0x01;
 217   1                      CKCON |= 0x04;
 218   1                      TCON_TR0=0;
 219   1                      TCON_TF0=0;
 220   1                      TH0=0;
 221   1                      TL0=0;
 222   1      
 223   1      }
 224          
 225          void Start_Stop_timer()
 226          {
 227   1              if(PWM_toggle())
 228   1              {
 229   2      
 230   2                      TCON_TR0=1;
 231   2      
 232   2                      if(PWM_toggle())
 233   2                      {
 234   3                              TCON_TR0=0;
 235   3                              TL0Temp= TL0;
 236   3                              TH0Temp= TH0;
 237   3                      }
 238   2              }
 239   1      }
 240          
 241          unsigned char PWM_toggle()
C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 5   

 242          {
 243   1              unsigned long i,j;
 244   1      
 245   1              for(i=0;i<=0xfff;i++)
 246   1              {
 247   2                      if(!P0_B7)break;
 248   2                      i+=1;
 249   2              }
 250   1      
 251   1              for(j=0;j<=0xfff;j++)
 252   1              {
 253   2                      if(P0_B7)break;
 254   2                      j+=1;
 255   2              }
 256   1              return true;
 257   1      }
 258          
 259          void Interrupts_Init()
 260          {
 261   1              IE_EA = 1;
 262   1              IE_ET2 = 1;
 263   1      }
 264          // Peripheral specific initialization functions,
 265          // Called from the Init_Device() function
 266          void Port_IO_Init()
 267          {
 268   1          // P0.0  -  Unassigned,  Push-Pull,  Digital
 269   1          // P0.1  -  Unassigned,  Open-Drain, Digital
 270   1          // P0.2  -  Unassigned,  Push-Pull,  Digital
 271   1          // P0.3  -  Unassigned,  Push-Pull,  Digital
 272   1          // P0.4  -  Unassigned,  Open-Drain, Digital
 273   1          // P0.5  -  Unassigned,  Push-Pull,  Digital
 274   1          // P0.6  -  Unassigned,  Open-Drain, Digital
 275   1          // P0.7  -  Unassigned,  Open-Drain, Digital
 276   1      
 277   1          P0MDOUT   |= 0x2D;
 278   1          P0        = 0x39;
 279   1          XBR2      = 0xC0;
 280   1      }
 281          
 282          // Initialization function for device,
 283          // Call Init_Device() from your main program
 284          void Init_Device(void)
 285          {
 286   1          Port_IO_Init();
 287   1      }
 288          
 289          /*----------------------------------------------------------------------*/
 290          /* ms delay routine */
 291          void wait_ms(unsigned short m_second)
 292          {
 293   1      
 294   1              TCON &= ~0xC0;
 295   1          TMOD &= ~0xF0;
 296   1          TMOD |=  0x10;
 297   1          CKCON |= 0x10;
 298   1      
 299   1              while (m_second)
 300   1              {
 301   2                      //TR1 = 0;
 302   2                      TCON &= ~0x40;
 303   2                      TH1 = 0xF4;
 304   2                      TL1 = 0x09;
C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 6   

 305   2                      //TF1 = 0;
 306   2                      TCON &= ~0x80;          /* Clear overflow indicator*/
 307   2                      //TR1 = 1;
 308   2                      TCON |= 0x40;
 309   2                      while (!(CKCON & 0x80))
 310   2                      {
 311   3                              _nop_();
 312   3                      }
 313   2                      m_second--;
 314   2              }
 315   1          //TR1 = 0;
 316   1          TCON &= ~0x40;                      /* Stop Timer1 */
 317   1      }
 318          
 319          
 320          /*
 321          void Timer2_Init(void)
 322          {
 323             CKCON &= ~0x60;                     // Timer2 uses SYSCLK/12
 324             TMR2CN &= ~0x01;
 325          
 326             TMR2RL = TIMER2_RELOAD;             // Reload value to be used in Timer2
 327             TMR2 = TMR2RL;                      // Init the Timer2 register
 328          
 329             TMR2CN = 0x04;                      // Enable Timer2 in auto-reload mode
 330             IE_ET2 = 1;                            // Timer2 interrupt enabled
 331          }
 332          */
 333          
 334          void Timer2_Init(void)
 335          {
 336   1              TMR2CN = 0x00;          // 16bit自动装载方式
 337   1              TMR2RLL = 0x4F;         // 设定100ms
 338   1              TMR2RLH = 0x9C;
 339   1      
 340   1              TMR2L = 0x4F;
 341   1              TMR2H = 0x9C;
 342   1      
 343   1              //TR2 = 1;
 344   1              TMR2CN_TR2 = 0;                         // enable timer2
 345   1      }
 346          
 347          void Timer2_Disable(void)
 348          {
 349   1      
 350   1              //timer2recording = 0x0000;     //clear count
 351   1              //TR2 = 0;
 352   1              TMR2CN_TR2 = 0;                         // Disable timer2
 353   1              timer2recording = 0x0000;
 354   1      }
 355          
 356          void Timer2_Enable(void)
 357          {
 358   1              timer2recording = 0x0000;
 359   1              //TR2 = 1;
 360   1              TMR2CN_TR2 = 1;                         // Enable timer2
 361   1              //ET2 = 1;
 362   1              IE_ET2 = 1;                             // Enable Timer2 interrupt
 363   1              //EA = 1;                                       // Enable All interrupt control
 364   1      }
 365          
 366          //-----------------------------------------------------------------------------
 367          // Interrupt Service Routines
C51 COMPILER V9.60.0.0   GF68_8051_MAIN                                                    03/11/2021 16:43:09 PAGE 7   

 368          //-----------------------------------------------------------------------------
 369          
 370          //-----------------------------------------------------------------------------
 371          // Timer2_ISR
 372          //-----------------------------------------------------------------------------
 373          //
 374          // Here we process the Timer2 interrupt and toggle the LED
 375          //
 376          //-----------------------------------------------------------------------------
 377          INTERRUPT_PROTO(Timer2_ISR, 5)
 378          {
 379   1         TMR2CN_TF2H = 0;                           // Reset Interrupt
 380   1         timer2recording++;
 381   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    784    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
